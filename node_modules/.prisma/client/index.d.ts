import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
} from '@prisma/client/runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw }

/**
 * Prisma Client JS version: 2.2.0
 * Query Engine version: e11114fa1ea826f9e7b4fa1ced34e78892fe8e0e
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export declare type InputJsonObject = {[Key in string]?: JsonValue}
 
export declare interface InputJsonArray extends Array<JsonValue> {}
 
export declare type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export declare type TrueKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string, collectTimestamps?: any): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/

export declare type Datasource = {
  url?: string
}

export type Datasources = {
  db?: Datasource
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * ```
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends Array<LogLevel | LogDefinition>> = GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]> 

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Answersheets
 * const answersheets = await prisma.answersheet.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md).
 */
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = keyof T extends 'log' ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Answersheets
   * const answersheets = await prisma.answersheet.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md).
   */
  constructor(optionsArg?: T);
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  connect(): Promise<void>;
  /**
   * @private
   */
  private runDisconnect;
  /**
   * Disconnect from the database
   */
  disconnect(): Promise<any>;

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md#raw-database-access).
  */
  executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md#raw-database-access).
  */
  queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;

  /**
   * `prisma.answersheet`: Exposes CRUD operations for the **Answersheet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answersheets
    * const answersheets = await prisma.answersheet.findMany()
    * ```
    */
  get answersheet(): AnswersheetDelegate;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): CourseDelegate;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): ExamDelegate;

  /**
   * `prisma.owner`: Exposes CRUD operations for the **Owner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Owners
    * const owners = await prisma.owner.findMany()
    * ```
    */
  get owner(): OwnerDelegate;

  /**
   * `prisma.person`: Exposes CRUD operations for the **Person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more People
    * const people = await prisma.person.findMany()
    * ```
    */
  get person(): PersonDelegate;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): QuestionDelegate;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): StudentDelegate;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): AdminDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const OrderByArg: {
  asc: 'asc',
  desc: 'desc'
};

export declare type OrderByArg = (typeof OrderByArg)[keyof typeof OrderByArg]



/**
 * Model Answersheet
 */

export type Answersheet = {
  answers: number[]
  score: number | null
  date: string
  exam_id: number
  id: number
  student_id: number
}



export type AnswersheetSelect = {
  answers?: boolean
  score?: boolean
  date?: boolean
  exam_id?: boolean
  id?: boolean
  student_id?: boolean
  exam?: boolean | ExamArgs
  student?: boolean | StudentArgs
}

export type AnswersheetInclude = {
  exam?: boolean | ExamArgs
  student?: boolean | StudentArgs
}

export type AnswersheetGetPayload<
  S extends boolean | null | undefined | AnswersheetArgs,
  U = keyof S
> = S extends true
  ? Answersheet
  : S extends undefined
  ? never
  : S extends AnswersheetArgs | FindManyAnswersheetArgs
  ? 'include' extends U
    ? Answersheet  & {
      [P in TrueKeys<S['include']>]:
      P extends 'exam'
      ? ExamGetPayload<S['include'][P]> :
      P extends 'student'
      ? StudentGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Answersheet ? Answersheet[P]
: 
      P extends 'exam'
      ? ExamGetPayload<S['select'][P]> :
      P extends 'student'
      ? StudentGetPayload<S['select'][P]> : never
    }
  : Answersheet
: Answersheet


export interface AnswersheetDelegate {
  /**
   * Find zero or one Answersheet.
   * @param {FindOneAnswersheetArgs} args - Arguments to find a Answersheet
   * @example
   * // Get one Answersheet
   * const answersheet = await prisma.answersheet.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneAnswersheetArgs>(
    args: Subset<T, FindOneAnswersheetArgs>
  ): CheckSelect<T, Prisma__AnswersheetClient<Answersheet | null>, Prisma__AnswersheetClient<AnswersheetGetPayload<T> | null>>
  /**
   * Find zero or more Answersheets.
   * @param {FindManyAnswersheetArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Answersheets
   * const answersheets = await prisma.answersheet.findMany()
   * 
   * // Get first 10 Answersheets
   * const answersheets = await prisma.answersheet.findMany({ take: 10 })
   * 
   * // Only select the `answers`
   * const answersheetWithAnswersOnly = await prisma.answersheet.findMany({ select: { answers: true } })
   * 
  **/
  findMany<T extends FindManyAnswersheetArgs>(
    args?: Subset<T, FindManyAnswersheetArgs>
  ): CheckSelect<T, Promise<Array<Answersheet>>, Promise<Array<AnswersheetGetPayload<T>>>>
  /**
   * Create a Answersheet.
   * @param {AnswersheetCreateArgs} args - Arguments to create a Answersheet.
   * @example
   * // Create one Answersheet
   * const Answersheet = await prisma.answersheet.create({
   *   data: {
   *     // ... data to create a Answersheet
   *   }
   * })
   * 
  **/
  create<T extends AnswersheetCreateArgs>(
    args: Subset<T, AnswersheetCreateArgs>
  ): CheckSelect<T, Prisma__AnswersheetClient<Answersheet>, Prisma__AnswersheetClient<AnswersheetGetPayload<T>>>
  /**
   * Delete a Answersheet.
   * @param {AnswersheetDeleteArgs} args - Arguments to delete one Answersheet.
   * @example
   * // Delete one Answersheet
   * const Answersheet = await prisma.answersheet.delete({
   *   where: {
   *     // ... filter to delete one Answersheet
   *   }
   * })
   * 
  **/
  delete<T extends AnswersheetDeleteArgs>(
    args: Subset<T, AnswersheetDeleteArgs>
  ): CheckSelect<T, Prisma__AnswersheetClient<Answersheet>, Prisma__AnswersheetClient<AnswersheetGetPayload<T>>>
  /**
   * Update one Answersheet.
   * @param {AnswersheetUpdateArgs} args - Arguments to update one Answersheet.
   * @example
   * // Update one Answersheet
   * const answersheet = await prisma.answersheet.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends AnswersheetUpdateArgs>(
    args: Subset<T, AnswersheetUpdateArgs>
  ): CheckSelect<T, Prisma__AnswersheetClient<Answersheet>, Prisma__AnswersheetClient<AnswersheetGetPayload<T>>>
  /**
   * Delete zero or more Answersheets.
   * @param {AnswersheetDeleteManyArgs} args - Arguments to filter Answersheets to delete.
   * @example
   * // Delete a few Answersheets
   * const { count } = await prisma.answersheet.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends AnswersheetDeleteManyArgs>(
    args: Subset<T, AnswersheetDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Answersheets.
   * @param {AnswersheetUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Answersheets
   * const answersheet = await prisma.answersheet.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends AnswersheetUpdateManyArgs>(
    args: Subset<T, AnswersheetUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Answersheet.
   * @param {AnswersheetUpsertArgs} args - Arguments to update or create a Answersheet.
   * @example
   * // Update or create a Answersheet
   * const answersheet = await prisma.answersheet.upsert({
   *   create: {
   *     // ... data to create a Answersheet
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Answersheet we want to update
   *   }
   * })
  **/
  upsert<T extends AnswersheetUpsertArgs>(
    args: Subset<T, AnswersheetUpsertArgs>
  ): CheckSelect<T, Prisma__AnswersheetClient<Answersheet>, Prisma__AnswersheetClient<AnswersheetGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyAnswersheetArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Answersheet.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__AnswersheetClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  exam<T extends ExamArgs = {}>(args?: Subset<T, ExamArgs>): CheckSelect<T, Prisma__ExamClient<Exam | null>, Prisma__ExamClient<ExamGetPayload<T> | null>>;

  student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null>, Prisma__StudentClient<StudentGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Answersheet findOne
 */
export type FindOneAnswersheetArgs = {
  /**
   * Select specific fields to fetch from the Answersheet
  **/
  select?: AnswersheetSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswersheetInclude | null
  /**
   * Filter, which Answersheet to fetch.
  **/
  where: AnswersheetWhereUniqueInput
}


/**
 * Answersheet findMany
 */
export type FindManyAnswersheetArgs = {
  /**
   * Select specific fields to fetch from the Answersheet
  **/
  select?: AnswersheetSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswersheetInclude | null
  /**
   * Filter, which Answersheets to fetch.
  **/
  where?: AnswersheetWhereInput
  /**
   * Determine the order of the Answersheets to fetch.
  **/
  orderBy?: AnswersheetOrderByInput
  /**
   * Sets the position for listing Answersheets.
  **/
  cursor?: AnswersheetWhereUniqueInput
  /**
   * The number of Answersheets to fetch. If negative number, it will take Answersheets before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Answersheets.
  **/
  skip?: number
}


/**
 * Answersheet create
 */
export type AnswersheetCreateArgs = {
  /**
   * Select specific fields to fetch from the Answersheet
  **/
  select?: AnswersheetSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswersheetInclude | null
  /**
   * The data needed to create a Answersheet.
  **/
  data: AnswersheetCreateInput
}


/**
 * Answersheet update
 */
export type AnswersheetUpdateArgs = {
  /**
   * Select specific fields to fetch from the Answersheet
  **/
  select?: AnswersheetSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswersheetInclude | null
  /**
   * The data needed to update a Answersheet.
  **/
  data: AnswersheetUpdateInput
  /**
   * Choose, which Answersheet to update.
  **/
  where: AnswersheetWhereUniqueInput
}


/**
 * Answersheet updateMany
 */
export type AnswersheetUpdateManyArgs = {
  data: AnswersheetUpdateManyMutationInput
  where?: AnswersheetWhereInput
}


/**
 * Answersheet upsert
 */
export type AnswersheetUpsertArgs = {
  /**
   * Select specific fields to fetch from the Answersheet
  **/
  select?: AnswersheetSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswersheetInclude | null
  /**
   * The filter to search for the Answersheet to update in case it exists.
  **/
  where: AnswersheetWhereUniqueInput
  /**
   * In case the Answersheet found by the `where` argument doesn't exist, create a new Answersheet with this data.
  **/
  create: AnswersheetCreateInput
  /**
   * In case the Answersheet was found with the provided `where` argument, update it with this data.
  **/
  update: AnswersheetUpdateInput
}


/**
 * Answersheet delete
 */
export type AnswersheetDeleteArgs = {
  /**
   * Select specific fields to fetch from the Answersheet
  **/
  select?: AnswersheetSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswersheetInclude | null
  /**
   * Filter which Answersheet to delete.
  **/
  where: AnswersheetWhereUniqueInput
}


/**
 * Answersheet deleteMany
 */
export type AnswersheetDeleteManyArgs = {
  where?: AnswersheetWhereInput
}


/**
 * Answersheet without action
 */
export type AnswersheetArgs = {
  /**
   * Select specific fields to fetch from the Answersheet
  **/
  select?: AnswersheetSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AnswersheetInclude | null
}



/**
 * Model Course
 */

export type Course = {
  id: number
  description: string | null
  name: string
  startdate: string
}



export type CourseSelect = {
  id?: boolean
  description?: boolean
  name?: boolean
  startdate?: boolean
  exams?: boolean | FindManyExamArgs
  owner?: boolean | OwnerArgs
  students?: boolean | FindManyStudentArgs
}

export type CourseInclude = {
  exams?: boolean | FindManyExamArgs
  owner?: boolean | OwnerArgs
  students?: boolean | FindManyStudentArgs
}

export type CourseGetPayload<
  S extends boolean | null | undefined | CourseArgs,
  U = keyof S
> = S extends true
  ? Course
  : S extends undefined
  ? never
  : S extends CourseArgs | FindManyCourseArgs
  ? 'include' extends U
    ? Course  & {
      [P in TrueKeys<S['include']>]:
      P extends 'exams'
      ? Array<ExamGetPayload<S['include'][P]>> :
      P extends 'owner'
      ? OwnerGetPayload<S['include'][P]> :
      P extends 'students'
      ? Array<StudentGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Course ? Course[P]
: 
      P extends 'exams'
      ? Array<ExamGetPayload<S['select'][P]>> :
      P extends 'owner'
      ? OwnerGetPayload<S['select'][P]> :
      P extends 'students'
      ? Array<StudentGetPayload<S['select'][P]>> : never
    }
  : Course
: Course


export interface CourseDelegate {
  /**
   * Find zero or one Course.
   * @param {FindOneCourseArgs} args - Arguments to find a Course
   * @example
   * // Get one Course
   * const course = await prisma.course.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneCourseArgs>(
    args: Subset<T, FindOneCourseArgs>
  ): CheckSelect<T, Prisma__CourseClient<Course | null>, Prisma__CourseClient<CourseGetPayload<T> | null>>
  /**
   * Find zero or more Courses.
   * @param {FindManyCourseArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Courses
   * const courses = await prisma.course.findMany()
   * 
   * // Get first 10 Courses
   * const courses = await prisma.course.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyCourseArgs>(
    args?: Subset<T, FindManyCourseArgs>
  ): CheckSelect<T, Promise<Array<Course>>, Promise<Array<CourseGetPayload<T>>>>
  /**
   * Create a Course.
   * @param {CourseCreateArgs} args - Arguments to create a Course.
   * @example
   * // Create one Course
   * const Course = await prisma.course.create({
   *   data: {
   *     // ... data to create a Course
   *   }
   * })
   * 
  **/
  create<T extends CourseCreateArgs>(
    args: Subset<T, CourseCreateArgs>
  ): CheckSelect<T, Prisma__CourseClient<Course>, Prisma__CourseClient<CourseGetPayload<T>>>
  /**
   * Delete a Course.
   * @param {CourseDeleteArgs} args - Arguments to delete one Course.
   * @example
   * // Delete one Course
   * const Course = await prisma.course.delete({
   *   where: {
   *     // ... filter to delete one Course
   *   }
   * })
   * 
  **/
  delete<T extends CourseDeleteArgs>(
    args: Subset<T, CourseDeleteArgs>
  ): CheckSelect<T, Prisma__CourseClient<Course>, Prisma__CourseClient<CourseGetPayload<T>>>
  /**
   * Update one Course.
   * @param {CourseUpdateArgs} args - Arguments to update one Course.
   * @example
   * // Update one Course
   * const course = await prisma.course.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends CourseUpdateArgs>(
    args: Subset<T, CourseUpdateArgs>
  ): CheckSelect<T, Prisma__CourseClient<Course>, Prisma__CourseClient<CourseGetPayload<T>>>
  /**
   * Delete zero or more Courses.
   * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
   * @example
   * // Delete a few Courses
   * const { count } = await prisma.course.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends CourseDeleteManyArgs>(
    args: Subset<T, CourseDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Courses.
   * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Courses
   * const course = await prisma.course.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends CourseUpdateManyArgs>(
    args: Subset<T, CourseUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Course.
   * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
   * @example
   * // Update or create a Course
   * const course = await prisma.course.upsert({
   *   create: {
   *     // ... data to create a Course
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Course we want to update
   *   }
   * })
  **/
  upsert<T extends CourseUpsertArgs>(
    args: Subset<T, CourseUpsertArgs>
  ): CheckSelect<T, Prisma__CourseClient<Course>, Prisma__CourseClient<CourseGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyCourseArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Course.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__CourseClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  exams<T extends FindManyExamArgs = {}>(args?: Subset<T, FindManyExamArgs>): CheckSelect<T, Promise<Array<Exam>>, Promise<Array<ExamGetPayload<T>>>>;

  owner<T extends OwnerArgs = {}>(args?: Subset<T, OwnerArgs>): CheckSelect<T, Prisma__OwnerClient<Owner | null>, Prisma__OwnerClient<OwnerGetPayload<T> | null>>;

  students<T extends FindManyStudentArgs = {}>(args?: Subset<T, FindManyStudentArgs>): CheckSelect<T, Promise<Array<Student>>, Promise<Array<StudentGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Course findOne
 */
export type FindOneCourseArgs = {
  /**
   * Select specific fields to fetch from the Course
  **/
  select?: CourseSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CourseInclude | null
  /**
   * Filter, which Course to fetch.
  **/
  where: CourseWhereUniqueInput
}


/**
 * Course findMany
 */
export type FindManyCourseArgs = {
  /**
   * Select specific fields to fetch from the Course
  **/
  select?: CourseSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CourseInclude | null
  /**
   * Filter, which Courses to fetch.
  **/
  where?: CourseWhereInput
  /**
   * Determine the order of the Courses to fetch.
  **/
  orderBy?: CourseOrderByInput
  /**
   * Sets the position for listing Courses.
  **/
  cursor?: CourseWhereUniqueInput
  /**
   * The number of Courses to fetch. If negative number, it will take Courses before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Courses.
  **/
  skip?: number
}


/**
 * Course create
 */
export type CourseCreateArgs = {
  /**
   * Select specific fields to fetch from the Course
  **/
  select?: CourseSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CourseInclude | null
  /**
   * The data needed to create a Course.
  **/
  data: CourseCreateInput
}


/**
 * Course update
 */
export type CourseUpdateArgs = {
  /**
   * Select specific fields to fetch from the Course
  **/
  select?: CourseSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CourseInclude | null
  /**
   * The data needed to update a Course.
  **/
  data: CourseUpdateInput
  /**
   * Choose, which Course to update.
  **/
  where: CourseWhereUniqueInput
}


/**
 * Course updateMany
 */
export type CourseUpdateManyArgs = {
  data: CourseUpdateManyMutationInput
  where?: CourseWhereInput
}


/**
 * Course upsert
 */
export type CourseUpsertArgs = {
  /**
   * Select specific fields to fetch from the Course
  **/
  select?: CourseSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CourseInclude | null
  /**
   * The filter to search for the Course to update in case it exists.
  **/
  where: CourseWhereUniqueInput
  /**
   * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
  **/
  create: CourseCreateInput
  /**
   * In case the Course was found with the provided `where` argument, update it with this data.
  **/
  update: CourseUpdateInput
}


/**
 * Course delete
 */
export type CourseDeleteArgs = {
  /**
   * Select specific fields to fetch from the Course
  **/
  select?: CourseSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CourseInclude | null
  /**
   * Filter which Course to delete.
  **/
  where: CourseWhereUniqueInput
}


/**
 * Course deleteMany
 */
export type CourseDeleteManyArgs = {
  where?: CourseWhereInput
}


/**
 * Course without action
 */
export type CourseArgs = {
  /**
   * Select specific fields to fetch from the Course
  **/
  select?: CourseSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CourseInclude | null
}



/**
 * Model Exam
 */

export type Exam = {
  course_id: number
  title: string
  isCalculated: boolean
  date: string
  duration: number
  id: number
}



export type ExamSelect = {
  course_id?: boolean
  title?: boolean
  isCalculated?: boolean
  date?: boolean
  duration?: boolean
  id?: boolean
  course?: boolean | CourseArgs
  answersheets?: boolean | FindManyAnswersheetArgs
  questions?: boolean | FindManyQuestionArgs
}

export type ExamInclude = {
  course?: boolean | CourseArgs
  answersheets?: boolean | FindManyAnswersheetArgs
  questions?: boolean | FindManyQuestionArgs
}

export type ExamGetPayload<
  S extends boolean | null | undefined | ExamArgs,
  U = keyof S
> = S extends true
  ? Exam
  : S extends undefined
  ? never
  : S extends ExamArgs | FindManyExamArgs
  ? 'include' extends U
    ? Exam  & {
      [P in TrueKeys<S['include']>]:
      P extends 'course'
      ? CourseGetPayload<S['include'][P]> :
      P extends 'answersheets'
      ? Array<AnswersheetGetPayload<S['include'][P]>> :
      P extends 'questions'
      ? Array<QuestionGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Exam ? Exam[P]
: 
      P extends 'course'
      ? CourseGetPayload<S['select'][P]> :
      P extends 'answersheets'
      ? Array<AnswersheetGetPayload<S['select'][P]>> :
      P extends 'questions'
      ? Array<QuestionGetPayload<S['select'][P]>> : never
    }
  : Exam
: Exam


export interface ExamDelegate {
  /**
   * Find zero or one Exam.
   * @param {FindOneExamArgs} args - Arguments to find a Exam
   * @example
   * // Get one Exam
   * const exam = await prisma.exam.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneExamArgs>(
    args: Subset<T, FindOneExamArgs>
  ): CheckSelect<T, Prisma__ExamClient<Exam | null>, Prisma__ExamClient<ExamGetPayload<T> | null>>
  /**
   * Find zero or more Exams.
   * @param {FindManyExamArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Exams
   * const exams = await prisma.exam.findMany()
   * 
   * // Get first 10 Exams
   * const exams = await prisma.exam.findMany({ take: 10 })
   * 
   * // Only select the `course_id`
   * const examWithCourse_idOnly = await prisma.exam.findMany({ select: { course_id: true } })
   * 
  **/
  findMany<T extends FindManyExamArgs>(
    args?: Subset<T, FindManyExamArgs>
  ): CheckSelect<T, Promise<Array<Exam>>, Promise<Array<ExamGetPayload<T>>>>
  /**
   * Create a Exam.
   * @param {ExamCreateArgs} args - Arguments to create a Exam.
   * @example
   * // Create one Exam
   * const Exam = await prisma.exam.create({
   *   data: {
   *     // ... data to create a Exam
   *   }
   * })
   * 
  **/
  create<T extends ExamCreateArgs>(
    args: Subset<T, ExamCreateArgs>
  ): CheckSelect<T, Prisma__ExamClient<Exam>, Prisma__ExamClient<ExamGetPayload<T>>>
  /**
   * Delete a Exam.
   * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
   * @example
   * // Delete one Exam
   * const Exam = await prisma.exam.delete({
   *   where: {
   *     // ... filter to delete one Exam
   *   }
   * })
   * 
  **/
  delete<T extends ExamDeleteArgs>(
    args: Subset<T, ExamDeleteArgs>
  ): CheckSelect<T, Prisma__ExamClient<Exam>, Prisma__ExamClient<ExamGetPayload<T>>>
  /**
   * Update one Exam.
   * @param {ExamUpdateArgs} args - Arguments to update one Exam.
   * @example
   * // Update one Exam
   * const exam = await prisma.exam.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ExamUpdateArgs>(
    args: Subset<T, ExamUpdateArgs>
  ): CheckSelect<T, Prisma__ExamClient<Exam>, Prisma__ExamClient<ExamGetPayload<T>>>
  /**
   * Delete zero or more Exams.
   * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
   * @example
   * // Delete a few Exams
   * const { count } = await prisma.exam.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ExamDeleteManyArgs>(
    args: Subset<T, ExamDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Exams.
   * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Exams
   * const exam = await prisma.exam.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ExamUpdateManyArgs>(
    args: Subset<T, ExamUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Exam.
   * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
   * @example
   * // Update or create a Exam
   * const exam = await prisma.exam.upsert({
   *   create: {
   *     // ... data to create a Exam
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Exam we want to update
   *   }
   * })
  **/
  upsert<T extends ExamUpsertArgs>(
    args: Subset<T, ExamUpsertArgs>
  ): CheckSelect<T, Prisma__ExamClient<Exam>, Prisma__ExamClient<ExamGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyExamArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Exam.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ExamClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  course<T extends CourseArgs = {}>(args?: Subset<T, CourseArgs>): CheckSelect<T, Prisma__CourseClient<Course | null>, Prisma__CourseClient<CourseGetPayload<T> | null>>;

  answersheets<T extends FindManyAnswersheetArgs = {}>(args?: Subset<T, FindManyAnswersheetArgs>): CheckSelect<T, Promise<Array<Answersheet>>, Promise<Array<AnswersheetGetPayload<T>>>>;

  questions<T extends FindManyQuestionArgs = {}>(args?: Subset<T, FindManyQuestionArgs>): CheckSelect<T, Promise<Array<Question>>, Promise<Array<QuestionGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Exam findOne
 */
export type FindOneExamArgs = {
  /**
   * Select specific fields to fetch from the Exam
  **/
  select?: ExamSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ExamInclude | null
  /**
   * Filter, which Exam to fetch.
  **/
  where: ExamWhereUniqueInput
}


/**
 * Exam findMany
 */
export type FindManyExamArgs = {
  /**
   * Select specific fields to fetch from the Exam
  **/
  select?: ExamSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ExamInclude | null
  /**
   * Filter, which Exams to fetch.
  **/
  where?: ExamWhereInput
  /**
   * Determine the order of the Exams to fetch.
  **/
  orderBy?: ExamOrderByInput
  /**
   * Sets the position for listing Exams.
  **/
  cursor?: ExamWhereUniqueInput
  /**
   * The number of Exams to fetch. If negative number, it will take Exams before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Exams.
  **/
  skip?: number
}


/**
 * Exam create
 */
export type ExamCreateArgs = {
  /**
   * Select specific fields to fetch from the Exam
  **/
  select?: ExamSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ExamInclude | null
  /**
   * The data needed to create a Exam.
  **/
  data: ExamCreateInput
}


/**
 * Exam update
 */
export type ExamUpdateArgs = {
  /**
   * Select specific fields to fetch from the Exam
  **/
  select?: ExamSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ExamInclude | null
  /**
   * The data needed to update a Exam.
  **/
  data: ExamUpdateInput
  /**
   * Choose, which Exam to update.
  **/
  where: ExamWhereUniqueInput
}


/**
 * Exam updateMany
 */
export type ExamUpdateManyArgs = {
  data: ExamUpdateManyMutationInput
  where?: ExamWhereInput
}


/**
 * Exam upsert
 */
export type ExamUpsertArgs = {
  /**
   * Select specific fields to fetch from the Exam
  **/
  select?: ExamSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ExamInclude | null
  /**
   * The filter to search for the Exam to update in case it exists.
  **/
  where: ExamWhereUniqueInput
  /**
   * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
  **/
  create: ExamCreateInput
  /**
   * In case the Exam was found with the provided `where` argument, update it with this data.
  **/
  update: ExamUpdateInput
}


/**
 * Exam delete
 */
export type ExamDeleteArgs = {
  /**
   * Select specific fields to fetch from the Exam
  **/
  select?: ExamSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ExamInclude | null
  /**
   * Filter which Exam to delete.
  **/
  where: ExamWhereUniqueInput
}


/**
 * Exam deleteMany
 */
export type ExamDeleteManyArgs = {
  where?: ExamWhereInput
}


/**
 * Exam without action
 */
export type ExamArgs = {
  /**
   * Select specific fields to fetch from the Exam
  **/
  select?: ExamSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ExamInclude | null
}



/**
 * Model Owner
 */

export type Owner = {
  course_id: number
  id: number
  person_id: number
}



export type OwnerSelect = {
  course_id?: boolean
  id?: boolean
  person_id?: boolean
  course?: boolean | CourseArgs
  person?: boolean | PersonArgs
}

export type OwnerInclude = {
  course?: boolean | CourseArgs
  person?: boolean | PersonArgs
}

export type OwnerGetPayload<
  S extends boolean | null | undefined | OwnerArgs,
  U = keyof S
> = S extends true
  ? Owner
  : S extends undefined
  ? never
  : S extends OwnerArgs | FindManyOwnerArgs
  ? 'include' extends U
    ? Owner  & {
      [P in TrueKeys<S['include']>]:
      P extends 'course'
      ? CourseGetPayload<S['include'][P]> :
      P extends 'person'
      ? PersonGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Owner ? Owner[P]
: 
      P extends 'course'
      ? CourseGetPayload<S['select'][P]> :
      P extends 'person'
      ? PersonGetPayload<S['select'][P]> : never
    }
  : Owner
: Owner


export interface OwnerDelegate {
  /**
   * Find zero or one Owner.
   * @param {FindOneOwnerArgs} args - Arguments to find a Owner
   * @example
   * // Get one Owner
   * const owner = await prisma.owner.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneOwnerArgs>(
    args: Subset<T, FindOneOwnerArgs>
  ): CheckSelect<T, Prisma__OwnerClient<Owner | null>, Prisma__OwnerClient<OwnerGetPayload<T> | null>>
  /**
   * Find zero or more Owners.
   * @param {FindManyOwnerArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Owners
   * const owners = await prisma.owner.findMany()
   * 
   * // Get first 10 Owners
   * const owners = await prisma.owner.findMany({ take: 10 })
   * 
   * // Only select the `course_id`
   * const ownerWithCourse_idOnly = await prisma.owner.findMany({ select: { course_id: true } })
   * 
  **/
  findMany<T extends FindManyOwnerArgs>(
    args?: Subset<T, FindManyOwnerArgs>
  ): CheckSelect<T, Promise<Array<Owner>>, Promise<Array<OwnerGetPayload<T>>>>
  /**
   * Create a Owner.
   * @param {OwnerCreateArgs} args - Arguments to create a Owner.
   * @example
   * // Create one Owner
   * const Owner = await prisma.owner.create({
   *   data: {
   *     // ... data to create a Owner
   *   }
   * })
   * 
  **/
  create<T extends OwnerCreateArgs>(
    args: Subset<T, OwnerCreateArgs>
  ): CheckSelect<T, Prisma__OwnerClient<Owner>, Prisma__OwnerClient<OwnerGetPayload<T>>>
  /**
   * Delete a Owner.
   * @param {OwnerDeleteArgs} args - Arguments to delete one Owner.
   * @example
   * // Delete one Owner
   * const Owner = await prisma.owner.delete({
   *   where: {
   *     // ... filter to delete one Owner
   *   }
   * })
   * 
  **/
  delete<T extends OwnerDeleteArgs>(
    args: Subset<T, OwnerDeleteArgs>
  ): CheckSelect<T, Prisma__OwnerClient<Owner>, Prisma__OwnerClient<OwnerGetPayload<T>>>
  /**
   * Update one Owner.
   * @param {OwnerUpdateArgs} args - Arguments to update one Owner.
   * @example
   * // Update one Owner
   * const owner = await prisma.owner.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends OwnerUpdateArgs>(
    args: Subset<T, OwnerUpdateArgs>
  ): CheckSelect<T, Prisma__OwnerClient<Owner>, Prisma__OwnerClient<OwnerGetPayload<T>>>
  /**
   * Delete zero or more Owners.
   * @param {OwnerDeleteManyArgs} args - Arguments to filter Owners to delete.
   * @example
   * // Delete a few Owners
   * const { count } = await prisma.owner.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends OwnerDeleteManyArgs>(
    args: Subset<T, OwnerDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Owners.
   * @param {OwnerUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Owners
   * const owner = await prisma.owner.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends OwnerUpdateManyArgs>(
    args: Subset<T, OwnerUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Owner.
   * @param {OwnerUpsertArgs} args - Arguments to update or create a Owner.
   * @example
   * // Update or create a Owner
   * const owner = await prisma.owner.upsert({
   *   create: {
   *     // ... data to create a Owner
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Owner we want to update
   *   }
   * })
  **/
  upsert<T extends OwnerUpsertArgs>(
    args: Subset<T, OwnerUpsertArgs>
  ): CheckSelect<T, Prisma__OwnerClient<Owner>, Prisma__OwnerClient<OwnerGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyOwnerArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Owner.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__OwnerClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  course<T extends CourseArgs = {}>(args?: Subset<T, CourseArgs>): CheckSelect<T, Prisma__CourseClient<Course | null>, Prisma__CourseClient<CourseGetPayload<T> | null>>;

  person<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null>, Prisma__PersonClient<PersonGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Owner findOne
 */
export type FindOneOwnerArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * Filter, which Owner to fetch.
  **/
  where: OwnerWhereUniqueInput
}


/**
 * Owner findMany
 */
export type FindManyOwnerArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * Filter, which Owners to fetch.
  **/
  where?: OwnerWhereInput
  /**
   * Determine the order of the Owners to fetch.
  **/
  orderBy?: OwnerOrderByInput
  /**
   * Sets the position for listing Owners.
  **/
  cursor?: OwnerWhereUniqueInput
  /**
   * The number of Owners to fetch. If negative number, it will take Owners before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Owners.
  **/
  skip?: number
}


/**
 * Owner create
 */
export type OwnerCreateArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * The data needed to create a Owner.
  **/
  data: OwnerCreateInput
}


/**
 * Owner update
 */
export type OwnerUpdateArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * The data needed to update a Owner.
  **/
  data: OwnerUpdateInput
  /**
   * Choose, which Owner to update.
  **/
  where: OwnerWhereUniqueInput
}


/**
 * Owner updateMany
 */
export type OwnerUpdateManyArgs = {
  data: OwnerUpdateManyMutationInput
  where?: OwnerWhereInput
}


/**
 * Owner upsert
 */
export type OwnerUpsertArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * The filter to search for the Owner to update in case it exists.
  **/
  where: OwnerWhereUniqueInput
  /**
   * In case the Owner found by the `where` argument doesn't exist, create a new Owner with this data.
  **/
  create: OwnerCreateInput
  /**
   * In case the Owner was found with the provided `where` argument, update it with this data.
  **/
  update: OwnerUpdateInput
}


/**
 * Owner delete
 */
export type OwnerDeleteArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * Filter which Owner to delete.
  **/
  where: OwnerWhereUniqueInput
}


/**
 * Owner deleteMany
 */
export type OwnerDeleteManyArgs = {
  where?: OwnerWhereInput
}


/**
 * Owner without action
 */
export type OwnerArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
}



/**
 * Model Person
 */

export type Person = {
  email: string
  password: string
  name: string
  id: number
}



export type PersonSelect = {
  email?: boolean
  password?: boolean
  name?: boolean
  id?: boolean
  owners?: boolean | FindManyOwnerArgs
  students?: boolean | FindManyStudentArgs
}

export type PersonInclude = {
  owners?: boolean | FindManyOwnerArgs
  students?: boolean | FindManyStudentArgs
}

export type PersonGetPayload<
  S extends boolean | null | undefined | PersonArgs,
  U = keyof S
> = S extends true
  ? Person
  : S extends undefined
  ? never
  : S extends PersonArgs | FindManyPersonArgs
  ? 'include' extends U
    ? Person  & {
      [P in TrueKeys<S['include']>]:
      P extends 'owners'
      ? Array<OwnerGetPayload<S['include'][P]>> :
      P extends 'students'
      ? Array<StudentGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Person ? Person[P]
: 
      P extends 'owners'
      ? Array<OwnerGetPayload<S['select'][P]>> :
      P extends 'students'
      ? Array<StudentGetPayload<S['select'][P]>> : never
    }
  : Person
: Person


export interface PersonDelegate {
  /**
   * Find zero or one Person.
   * @param {FindOnePersonArgs} args - Arguments to find a Person
   * @example
   * // Get one Person
   * const person = await prisma.person.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnePersonArgs>(
    args: Subset<T, FindOnePersonArgs>
  ): CheckSelect<T, Prisma__PersonClient<Person | null>, Prisma__PersonClient<PersonGetPayload<T> | null>>
  /**
   * Find zero or more People.
   * @param {FindManyPersonArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all People
   * const people = await prisma.person.findMany()
   * 
   * // Get first 10 People
   * const people = await prisma.person.findMany({ take: 10 })
   * 
   * // Only select the `email`
   * const personWithEmailOnly = await prisma.person.findMany({ select: { email: true } })
   * 
  **/
  findMany<T extends FindManyPersonArgs>(
    args?: Subset<T, FindManyPersonArgs>
  ): CheckSelect<T, Promise<Array<Person>>, Promise<Array<PersonGetPayload<T>>>>
  /**
   * Create a Person.
   * @param {PersonCreateArgs} args - Arguments to create a Person.
   * @example
   * // Create one Person
   * const Person = await prisma.person.create({
   *   data: {
   *     // ... data to create a Person
   *   }
   * })
   * 
  **/
  create<T extends PersonCreateArgs>(
    args: Subset<T, PersonCreateArgs>
  ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>
  /**
   * Delete a Person.
   * @param {PersonDeleteArgs} args - Arguments to delete one Person.
   * @example
   * // Delete one Person
   * const Person = await prisma.person.delete({
   *   where: {
   *     // ... filter to delete one Person
   *   }
   * })
   * 
  **/
  delete<T extends PersonDeleteArgs>(
    args: Subset<T, PersonDeleteArgs>
  ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>
  /**
   * Update one Person.
   * @param {PersonUpdateArgs} args - Arguments to update one Person.
   * @example
   * // Update one Person
   * const person = await prisma.person.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends PersonUpdateArgs>(
    args: Subset<T, PersonUpdateArgs>
  ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>
  /**
   * Delete zero or more People.
   * @param {PersonDeleteManyArgs} args - Arguments to filter People to delete.
   * @example
   * // Delete a few People
   * const { count } = await prisma.person.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends PersonDeleteManyArgs>(
    args: Subset<T, PersonDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more People.
   * @param {PersonUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many People
   * const person = await prisma.person.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends PersonUpdateManyArgs>(
    args: Subset<T, PersonUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Person.
   * @param {PersonUpsertArgs} args - Arguments to update or create a Person.
   * @example
   * // Update or create a Person
   * const person = await prisma.person.upsert({
   *   create: {
   *     // ... data to create a Person
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Person we want to update
   *   }
   * })
  **/
  upsert<T extends PersonUpsertArgs>(
    args: Subset<T, PersonUpsertArgs>
  ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyPersonArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Person.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__PersonClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  owners<T extends FindManyOwnerArgs = {}>(args?: Subset<T, FindManyOwnerArgs>): CheckSelect<T, Promise<Array<Owner>>, Promise<Array<OwnerGetPayload<T>>>>;

  students<T extends FindManyStudentArgs = {}>(args?: Subset<T, FindManyStudentArgs>): CheckSelect<T, Promise<Array<Student>>, Promise<Array<StudentGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Person findOne
 */
export type FindOnePersonArgs = {
  /**
   * Select specific fields to fetch from the Person
  **/
  select?: PersonSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PersonInclude | null
  /**
   * Filter, which Person to fetch.
  **/
  where: PersonWhereUniqueInput
}


/**
 * Person findMany
 */
export type FindManyPersonArgs = {
  /**
   * Select specific fields to fetch from the Person
  **/
  select?: PersonSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PersonInclude | null
  /**
   * Filter, which People to fetch.
  **/
  where?: PersonWhereInput
  /**
   * Determine the order of the People to fetch.
  **/
  orderBy?: PersonOrderByInput
  /**
   * Sets the position for listing People.
  **/
  cursor?: PersonWhereUniqueInput
  /**
   * The number of People to fetch. If negative number, it will take People before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` People.
  **/
  skip?: number
}


/**
 * Person create
 */
export type PersonCreateArgs = {
  /**
   * Select specific fields to fetch from the Person
  **/
  select?: PersonSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PersonInclude | null
  /**
   * The data needed to create a Person.
  **/
  data: PersonCreateInput
}


/**
 * Person update
 */
export type PersonUpdateArgs = {
  /**
   * Select specific fields to fetch from the Person
  **/
  select?: PersonSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PersonInclude | null
  /**
   * The data needed to update a Person.
  **/
  data: PersonUpdateInput
  /**
   * Choose, which Person to update.
  **/
  where: PersonWhereUniqueInput
}


/**
 * Person updateMany
 */
export type PersonUpdateManyArgs = {
  data: PersonUpdateManyMutationInput
  where?: PersonWhereInput
}


/**
 * Person upsert
 */
export type PersonUpsertArgs = {
  /**
   * Select specific fields to fetch from the Person
  **/
  select?: PersonSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PersonInclude | null
  /**
   * The filter to search for the Person to update in case it exists.
  **/
  where: PersonWhereUniqueInput
  /**
   * In case the Person found by the `where` argument doesn't exist, create a new Person with this data.
  **/
  create: PersonCreateInput
  /**
   * In case the Person was found with the provided `where` argument, update it with this data.
  **/
  update: PersonUpdateInput
}


/**
 * Person delete
 */
export type PersonDeleteArgs = {
  /**
   * Select specific fields to fetch from the Person
  **/
  select?: PersonSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PersonInclude | null
  /**
   * Filter which Person to delete.
  **/
  where: PersonWhereUniqueInput
}


/**
 * Person deleteMany
 */
export type PersonDeleteManyArgs = {
  where?: PersonWhereInput
}


/**
 * Person without action
 */
export type PersonArgs = {
  /**
   * Select specific fields to fetch from the Person
  **/
  select?: PersonSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PersonInclude | null
}



/**
 * Model Question
 */

export type Question = {
  answer: number
  choices: string[]
  exam_id: number
  id: number
  text: string
}



export type QuestionSelect = {
  answer?: boolean
  choices?: boolean
  exam_id?: boolean
  id?: boolean
  text?: boolean
  exam?: boolean | ExamArgs
}

export type QuestionInclude = {
  exam?: boolean | ExamArgs
}

export type QuestionGetPayload<
  S extends boolean | null | undefined | QuestionArgs,
  U = keyof S
> = S extends true
  ? Question
  : S extends undefined
  ? never
  : S extends QuestionArgs | FindManyQuestionArgs
  ? 'include' extends U
    ? Question  & {
      [P in TrueKeys<S['include']>]:
      P extends 'exam'
      ? ExamGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Question ? Question[P]
: 
      P extends 'exam'
      ? ExamGetPayload<S['select'][P]> : never
    }
  : Question
: Question


export interface QuestionDelegate {
  /**
   * Find zero or one Question.
   * @param {FindOneQuestionArgs} args - Arguments to find a Question
   * @example
   * // Get one Question
   * const question = await prisma.question.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneQuestionArgs>(
    args: Subset<T, FindOneQuestionArgs>
  ): CheckSelect<T, Prisma__QuestionClient<Question | null>, Prisma__QuestionClient<QuestionGetPayload<T> | null>>
  /**
   * Find zero or more Questions.
   * @param {FindManyQuestionArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Questions
   * const questions = await prisma.question.findMany()
   * 
   * // Get first 10 Questions
   * const questions = await prisma.question.findMany({ take: 10 })
   * 
   * // Only select the `answer`
   * const questionWithAnswerOnly = await prisma.question.findMany({ select: { answer: true } })
   * 
  **/
  findMany<T extends FindManyQuestionArgs>(
    args?: Subset<T, FindManyQuestionArgs>
  ): CheckSelect<T, Promise<Array<Question>>, Promise<Array<QuestionGetPayload<T>>>>
  /**
   * Create a Question.
   * @param {QuestionCreateArgs} args - Arguments to create a Question.
   * @example
   * // Create one Question
   * const Question = await prisma.question.create({
   *   data: {
   *     // ... data to create a Question
   *   }
   * })
   * 
  **/
  create<T extends QuestionCreateArgs>(
    args: Subset<T, QuestionCreateArgs>
  ): CheckSelect<T, Prisma__QuestionClient<Question>, Prisma__QuestionClient<QuestionGetPayload<T>>>
  /**
   * Delete a Question.
   * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
   * @example
   * // Delete one Question
   * const Question = await prisma.question.delete({
   *   where: {
   *     // ... filter to delete one Question
   *   }
   * })
   * 
  **/
  delete<T extends QuestionDeleteArgs>(
    args: Subset<T, QuestionDeleteArgs>
  ): CheckSelect<T, Prisma__QuestionClient<Question>, Prisma__QuestionClient<QuestionGetPayload<T>>>
  /**
   * Update one Question.
   * @param {QuestionUpdateArgs} args - Arguments to update one Question.
   * @example
   * // Update one Question
   * const question = await prisma.question.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends QuestionUpdateArgs>(
    args: Subset<T, QuestionUpdateArgs>
  ): CheckSelect<T, Prisma__QuestionClient<Question>, Prisma__QuestionClient<QuestionGetPayload<T>>>
  /**
   * Delete zero or more Questions.
   * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
   * @example
   * // Delete a few Questions
   * const { count } = await prisma.question.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends QuestionDeleteManyArgs>(
    args: Subset<T, QuestionDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Questions.
   * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Questions
   * const question = await prisma.question.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends QuestionUpdateManyArgs>(
    args: Subset<T, QuestionUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Question.
   * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
   * @example
   * // Update or create a Question
   * const question = await prisma.question.upsert({
   *   create: {
   *     // ... data to create a Question
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Question we want to update
   *   }
   * })
  **/
  upsert<T extends QuestionUpsertArgs>(
    args: Subset<T, QuestionUpsertArgs>
  ): CheckSelect<T, Prisma__QuestionClient<Question>, Prisma__QuestionClient<QuestionGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyQuestionArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Question.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__QuestionClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  exam<T extends ExamArgs = {}>(args?: Subset<T, ExamArgs>): CheckSelect<T, Prisma__ExamClient<Exam | null>, Prisma__ExamClient<ExamGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Question findOne
 */
export type FindOneQuestionArgs = {
  /**
   * Select specific fields to fetch from the Question
  **/
  select?: QuestionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionInclude | null
  /**
   * Filter, which Question to fetch.
  **/
  where: QuestionWhereUniqueInput
}


/**
 * Question findMany
 */
export type FindManyQuestionArgs = {
  /**
   * Select specific fields to fetch from the Question
  **/
  select?: QuestionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionInclude | null
  /**
   * Filter, which Questions to fetch.
  **/
  where?: QuestionWhereInput
  /**
   * Determine the order of the Questions to fetch.
  **/
  orderBy?: QuestionOrderByInput
  /**
   * Sets the position for listing Questions.
  **/
  cursor?: QuestionWhereUniqueInput
  /**
   * The number of Questions to fetch. If negative number, it will take Questions before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Questions.
  **/
  skip?: number
}


/**
 * Question create
 */
export type QuestionCreateArgs = {
  /**
   * Select specific fields to fetch from the Question
  **/
  select?: QuestionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionInclude | null
  /**
   * The data needed to create a Question.
  **/
  data: QuestionCreateInput
}


/**
 * Question update
 */
export type QuestionUpdateArgs = {
  /**
   * Select specific fields to fetch from the Question
  **/
  select?: QuestionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionInclude | null
  /**
   * The data needed to update a Question.
  **/
  data: QuestionUpdateInput
  /**
   * Choose, which Question to update.
  **/
  where: QuestionWhereUniqueInput
}


/**
 * Question updateMany
 */
export type QuestionUpdateManyArgs = {
  data: QuestionUpdateManyMutationInput
  where?: QuestionWhereInput
}


/**
 * Question upsert
 */
export type QuestionUpsertArgs = {
  /**
   * Select specific fields to fetch from the Question
  **/
  select?: QuestionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionInclude | null
  /**
   * The filter to search for the Question to update in case it exists.
  **/
  where: QuestionWhereUniqueInput
  /**
   * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
  **/
  create: QuestionCreateInput
  /**
   * In case the Question was found with the provided `where` argument, update it with this data.
  **/
  update: QuestionUpdateInput
}


/**
 * Question delete
 */
export type QuestionDeleteArgs = {
  /**
   * Select specific fields to fetch from the Question
  **/
  select?: QuestionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionInclude | null
  /**
   * Filter which Question to delete.
  **/
  where: QuestionWhereUniqueInput
}


/**
 * Question deleteMany
 */
export type QuestionDeleteManyArgs = {
  where?: QuestionWhereInput
}


/**
 * Question without action
 */
export type QuestionArgs = {
  /**
   * Select specific fields to fetch from the Question
  **/
  select?: QuestionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: QuestionInclude | null
}



/**
 * Model Student
 */

export type Student = {
  course_id: number
  id: number
  person_id: number
}



export type StudentSelect = {
  course_id?: boolean
  id?: boolean
  person_id?: boolean
  course?: boolean | CourseArgs
  person?: boolean | PersonArgs
  answersheets?: boolean | FindManyAnswersheetArgs
}

export type StudentInclude = {
  course?: boolean | CourseArgs
  person?: boolean | PersonArgs
  answersheets?: boolean | FindManyAnswersheetArgs
}

export type StudentGetPayload<
  S extends boolean | null | undefined | StudentArgs,
  U = keyof S
> = S extends true
  ? Student
  : S extends undefined
  ? never
  : S extends StudentArgs | FindManyStudentArgs
  ? 'include' extends U
    ? Student  & {
      [P in TrueKeys<S['include']>]:
      P extends 'course'
      ? CourseGetPayload<S['include'][P]> :
      P extends 'person'
      ? PersonGetPayload<S['include'][P]> :
      P extends 'answersheets'
      ? Array<AnswersheetGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Student ? Student[P]
: 
      P extends 'course'
      ? CourseGetPayload<S['select'][P]> :
      P extends 'person'
      ? PersonGetPayload<S['select'][P]> :
      P extends 'answersheets'
      ? Array<AnswersheetGetPayload<S['select'][P]>> : never
    }
  : Student
: Student


export interface StudentDelegate {
  /**
   * Find zero or one Student.
   * @param {FindOneStudentArgs} args - Arguments to find a Student
   * @example
   * // Get one Student
   * const student = await prisma.student.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneStudentArgs>(
    args: Subset<T, FindOneStudentArgs>
  ): CheckSelect<T, Prisma__StudentClient<Student | null>, Prisma__StudentClient<StudentGetPayload<T> | null>>
  /**
   * Find zero or more Students.
   * @param {FindManyStudentArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Students
   * const students = await prisma.student.findMany()
   * 
   * // Get first 10 Students
   * const students = await prisma.student.findMany({ take: 10 })
   * 
   * // Only select the `course_id`
   * const studentWithCourse_idOnly = await prisma.student.findMany({ select: { course_id: true } })
   * 
  **/
  findMany<T extends FindManyStudentArgs>(
    args?: Subset<T, FindManyStudentArgs>
  ): CheckSelect<T, Promise<Array<Student>>, Promise<Array<StudentGetPayload<T>>>>
  /**
   * Create a Student.
   * @param {StudentCreateArgs} args - Arguments to create a Student.
   * @example
   * // Create one Student
   * const Student = await prisma.student.create({
   *   data: {
   *     // ... data to create a Student
   *   }
   * })
   * 
  **/
  create<T extends StudentCreateArgs>(
    args: Subset<T, StudentCreateArgs>
  ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>
  /**
   * Delete a Student.
   * @param {StudentDeleteArgs} args - Arguments to delete one Student.
   * @example
   * // Delete one Student
   * const Student = await prisma.student.delete({
   *   where: {
   *     // ... filter to delete one Student
   *   }
   * })
   * 
  **/
  delete<T extends StudentDeleteArgs>(
    args: Subset<T, StudentDeleteArgs>
  ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>
  /**
   * Update one Student.
   * @param {StudentUpdateArgs} args - Arguments to update one Student.
   * @example
   * // Update one Student
   * const student = await prisma.student.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends StudentUpdateArgs>(
    args: Subset<T, StudentUpdateArgs>
  ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>
  /**
   * Delete zero or more Students.
   * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
   * @example
   * // Delete a few Students
   * const { count } = await prisma.student.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends StudentDeleteManyArgs>(
    args: Subset<T, StudentDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Students.
   * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Students
   * const student = await prisma.student.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends StudentUpdateManyArgs>(
    args: Subset<T, StudentUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Student.
   * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
   * @example
   * // Update or create a Student
   * const student = await prisma.student.upsert({
   *   create: {
   *     // ... data to create a Student
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Student we want to update
   *   }
   * })
  **/
  upsert<T extends StudentUpsertArgs>(
    args: Subset<T, StudentUpsertArgs>
  ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyStudentArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Student.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__StudentClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  course<T extends CourseArgs = {}>(args?: Subset<T, CourseArgs>): CheckSelect<T, Prisma__CourseClient<Course | null>, Prisma__CourseClient<CourseGetPayload<T> | null>>;

  person<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null>, Prisma__PersonClient<PersonGetPayload<T> | null>>;

  answersheets<T extends FindManyAnswersheetArgs = {}>(args?: Subset<T, FindManyAnswersheetArgs>): CheckSelect<T, Promise<Array<Answersheet>>, Promise<Array<AnswersheetGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Student findOne
 */
export type FindOneStudentArgs = {
  /**
   * Select specific fields to fetch from the Student
  **/
  select?: StudentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StudentInclude | null
  /**
   * Filter, which Student to fetch.
  **/
  where: StudentWhereUniqueInput
}


/**
 * Student findMany
 */
export type FindManyStudentArgs = {
  /**
   * Select specific fields to fetch from the Student
  **/
  select?: StudentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StudentInclude | null
  /**
   * Filter, which Students to fetch.
  **/
  where?: StudentWhereInput
  /**
   * Determine the order of the Students to fetch.
  **/
  orderBy?: StudentOrderByInput
  /**
   * Sets the position for listing Students.
  **/
  cursor?: StudentWhereUniqueInput
  /**
   * The number of Students to fetch. If negative number, it will take Students before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Students.
  **/
  skip?: number
}


/**
 * Student create
 */
export type StudentCreateArgs = {
  /**
   * Select specific fields to fetch from the Student
  **/
  select?: StudentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StudentInclude | null
  /**
   * The data needed to create a Student.
  **/
  data: StudentCreateInput
}


/**
 * Student update
 */
export type StudentUpdateArgs = {
  /**
   * Select specific fields to fetch from the Student
  **/
  select?: StudentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StudentInclude | null
  /**
   * The data needed to update a Student.
  **/
  data: StudentUpdateInput
  /**
   * Choose, which Student to update.
  **/
  where: StudentWhereUniqueInput
}


/**
 * Student updateMany
 */
export type StudentUpdateManyArgs = {
  data: StudentUpdateManyMutationInput
  where?: StudentWhereInput
}


/**
 * Student upsert
 */
export type StudentUpsertArgs = {
  /**
   * Select specific fields to fetch from the Student
  **/
  select?: StudentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StudentInclude | null
  /**
   * The filter to search for the Student to update in case it exists.
  **/
  where: StudentWhereUniqueInput
  /**
   * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
  **/
  create: StudentCreateInput
  /**
   * In case the Student was found with the provided `where` argument, update it with this data.
  **/
  update: StudentUpdateInput
}


/**
 * Student delete
 */
export type StudentDeleteArgs = {
  /**
   * Select specific fields to fetch from the Student
  **/
  select?: StudentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StudentInclude | null
  /**
   * Filter which Student to delete.
  **/
  where: StudentWhereUniqueInput
}


/**
 * Student deleteMany
 */
export type StudentDeleteManyArgs = {
  where?: StudentWhereInput
}


/**
 * Student without action
 */
export type StudentArgs = {
  /**
   * Select specific fields to fetch from the Student
  **/
  select?: StudentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StudentInclude | null
}



/**
 * Model Admin
 */

export type Admin = {
  id: number
  email: string
  password: string
}



export type AdminSelect = {
  id?: boolean
  email?: boolean
  password?: boolean
}

export type AdminGetPayload<
  S extends boolean | null | undefined | AdminArgs,
  U = keyof S
> = S extends true
  ? Admin
  : S extends undefined
  ? never
  : S extends AdminArgs | FindManyAdminArgs
  ? 'include' extends U
    ? Admin 
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Admin ? Admin[P]
: 
 never
    }
  : Admin
: Admin


export interface AdminDelegate {
  /**
   * Find zero or one Admin.
   * @param {FindOneAdminArgs} args - Arguments to find a Admin
   * @example
   * // Get one Admin
   * const admin = await prisma.admin.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneAdminArgs>(
    args: Subset<T, FindOneAdminArgs>
  ): CheckSelect<T, Prisma__AdminClient<Admin | null>, Prisma__AdminClient<AdminGetPayload<T> | null>>
  /**
   * Find zero or more Admins.
   * @param {FindManyAdminArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Admins
   * const admins = await prisma.admin.findMany()
   * 
   * // Get first 10 Admins
   * const admins = await prisma.admin.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyAdminArgs>(
    args?: Subset<T, FindManyAdminArgs>
  ): CheckSelect<T, Promise<Array<Admin>>, Promise<Array<AdminGetPayload<T>>>>
  /**
   * Create a Admin.
   * @param {AdminCreateArgs} args - Arguments to create a Admin.
   * @example
   * // Create one Admin
   * const Admin = await prisma.admin.create({
   *   data: {
   *     // ... data to create a Admin
   *   }
   * })
   * 
  **/
  create<T extends AdminCreateArgs>(
    args: Subset<T, AdminCreateArgs>
  ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>
  /**
   * Delete a Admin.
   * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
   * @example
   * // Delete one Admin
   * const Admin = await prisma.admin.delete({
   *   where: {
   *     // ... filter to delete one Admin
   *   }
   * })
   * 
  **/
  delete<T extends AdminDeleteArgs>(
    args: Subset<T, AdminDeleteArgs>
  ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>
  /**
   * Update one Admin.
   * @param {AdminUpdateArgs} args - Arguments to update one Admin.
   * @example
   * // Update one Admin
   * const admin = await prisma.admin.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends AdminUpdateArgs>(
    args: Subset<T, AdminUpdateArgs>
  ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>
  /**
   * Delete zero or more Admins.
   * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
   * @example
   * // Delete a few Admins
   * const { count } = await prisma.admin.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends AdminDeleteManyArgs>(
    args: Subset<T, AdminDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Admins.
   * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Admins
   * const admin = await prisma.admin.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends AdminUpdateManyArgs>(
    args: Subset<T, AdminUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Admin.
   * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
   * @example
   * // Update or create a Admin
   * const admin = await prisma.admin.upsert({
   *   create: {
   *     // ... data to create a Admin
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Admin we want to update
   *   }
   * })
  **/
  upsert<T extends AdminUpsertArgs>(
    args: Subset<T, AdminUpsertArgs>
  ): CheckSelect<T, Prisma__AdminClient<Admin>, Prisma__AdminClient<AdminGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyAdminArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Admin.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__AdminClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';


  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Admin findOne
 */
export type FindOneAdminArgs = {
  /**
   * Select specific fields to fetch from the Admin
  **/
  select?: AdminSelect | null
  /**
   * Filter, which Admin to fetch.
  **/
  where: AdminWhereUniqueInput
}


/**
 * Admin findMany
 */
export type FindManyAdminArgs = {
  /**
   * Select specific fields to fetch from the Admin
  **/
  select?: AdminSelect | null
  /**
   * Filter, which Admins to fetch.
  **/
  where?: AdminWhereInput
  /**
   * Determine the order of the Admins to fetch.
  **/
  orderBy?: AdminOrderByInput
  /**
   * Sets the position for listing Admins.
  **/
  cursor?: AdminWhereUniqueInput
  /**
   * The number of Admins to fetch. If negative number, it will take Admins before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Admins.
  **/
  skip?: number
}


/**
 * Admin create
 */
export type AdminCreateArgs = {
  /**
   * Select specific fields to fetch from the Admin
  **/
  select?: AdminSelect | null
  /**
   * The data needed to create a Admin.
  **/
  data: AdminCreateInput
}


/**
 * Admin update
 */
export type AdminUpdateArgs = {
  /**
   * Select specific fields to fetch from the Admin
  **/
  select?: AdminSelect | null
  /**
   * The data needed to update a Admin.
  **/
  data: AdminUpdateInput
  /**
   * Choose, which Admin to update.
  **/
  where: AdminWhereUniqueInput
}


/**
 * Admin updateMany
 */
export type AdminUpdateManyArgs = {
  data: AdminUpdateManyMutationInput
  where?: AdminWhereInput
}


/**
 * Admin upsert
 */
export type AdminUpsertArgs = {
  /**
   * Select specific fields to fetch from the Admin
  **/
  select?: AdminSelect | null
  /**
   * The filter to search for the Admin to update in case it exists.
  **/
  where: AdminWhereUniqueInput
  /**
   * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
  **/
  create: AdminCreateInput
  /**
   * In case the Admin was found with the provided `where` argument, update it with this data.
  **/
  update: AdminUpdateInput
}


/**
 * Admin delete
 */
export type AdminDeleteArgs = {
  /**
   * Select specific fields to fetch from the Admin
  **/
  select?: AdminSelect | null
  /**
   * Filter which Admin to delete.
  **/
  where: AdminWhereUniqueInput
}


/**
 * Admin deleteMany
 */
export type AdminDeleteManyArgs = {
  where?: AdminWhereInput
}


/**
 * Admin without action
 */
export type AdminArgs = {
  /**
   * Select specific fields to fetch from the Admin
  **/
  select?: AdminSelect | null
}



/**
 * Deep Input Types
 */


export type StudentWhereInput = {
  course_id?: number | IntFilter
  id?: number | IntFilter
  person_id?: number | IntFilter
  answersheets?: AnswersheetFilter | null
  AND?: Enumerable<StudentWhereInput>
  OR?: Array<StudentWhereInput>
  NOT?: Enumerable<StudentWhereInput>
  course?: CourseWhereInput | null
  person?: PersonWhereInput | null
}

export type PersonWhereInput = {
  email?: string | StringFilter
  password?: string | StringFilter
  name?: string | StringFilter
  id?: number | IntFilter
  owners?: OwnerFilter | null
  students?: StudentFilter | null
  AND?: Enumerable<PersonWhereInput>
  OR?: Array<PersonWhereInput>
  NOT?: Enumerable<PersonWhereInput>
}

export type OwnerWhereInput = {
  course_id?: number | IntFilter
  id?: number | IntFilter
  person_id?: number | IntFilter
  AND?: Enumerable<OwnerWhereInput>
  OR?: Array<OwnerWhereInput>
  NOT?: Enumerable<OwnerWhereInput>
  course?: CourseWhereInput | null
  person?: PersonWhereInput | null
}

export type CourseWhereInput = {
  id?: number | IntFilter
  description?: string | NullableStringFilter | null
  name?: string | StringFilter
  startdate?: string | StringFilter
  exams?: ExamFilter | null
  students?: StudentFilter | null
  AND?: Enumerable<CourseWhereInput>
  OR?: Array<CourseWhereInput>
  NOT?: Enumerable<CourseWhereInput>
  owner?: OwnerWhereInput | null
}

export type QuestionWhereInput = {
  answer?: number | IntFilter
  exam_id?: number | IntFilter
  id?: number | IntFilter
  text?: string | StringFilter
  AND?: Enumerable<QuestionWhereInput>
  OR?: Array<QuestionWhereInput>
  NOT?: Enumerable<QuestionWhereInput>
  exam?: ExamWhereInput | null
}

export type ExamWhereInput = {
  course_id?: number | IntFilter
  title?: string | StringFilter
  isCalculated?: boolean | BooleanFilter
  date?: string | StringFilter
  duration?: number | IntFilter
  id?: number | IntFilter
  answersheets?: AnswersheetFilter | null
  questions?: QuestionFilter | null
  AND?: Enumerable<ExamWhereInput>
  OR?: Array<ExamWhereInput>
  NOT?: Enumerable<ExamWhereInput>
  course?: CourseWhereInput | null
}

export type AnswersheetWhereInput = {
  score?: number | NullableIntFilter | null
  date?: string | StringFilter
  exam_id?: number | IntFilter
  id?: number | IntFilter
  student_id?: number | IntFilter
  AND?: Enumerable<AnswersheetWhereInput>
  OR?: Array<AnswersheetWhereInput>
  NOT?: Enumerable<AnswersheetWhereInput>
  exam?: ExamWhereInput | null
  student?: StudentWhereInput | null
}

export type AnswersheetWhereUniqueInput = {
  id?: number
}

export type ExamWhereUniqueInput = {
  id?: number
}

export type OwnerWhereUniqueInput = {
  course_id?: number
  id?: number
}

export type StudentWhereUniqueInput = {
  id?: number
}

export type QuestionWhereUniqueInput = {
  id?: number
}

export type CourseWhereUniqueInput = {
  id?: number
}

export type PersonWhereUniqueInput = {
  email?: string
  id?: number
}

export type AdminWhereInput = {
  id?: number | IntFilter
  email?: string | StringFilter
  password?: string | StringFilter
  AND?: Enumerable<AdminWhereInput>
  OR?: Array<AdminWhereInput>
  NOT?: Enumerable<AdminWhereInput>
}

export type AdminWhereUniqueInput = {
  id?: number
  email?: string
}

export type AnswersheetCreateanswersInput = {
  set?: Enumerable<number> | null
}

export type AnswersheetCreateWithoutStudentInput = {
  score?: number | null
  date: string
  answers?: AnswersheetCreateanswersInput
  exam: ExamCreateOneWithoutAnswersheetsInput
}

export type AnswersheetCreateManyWithoutStudentInput = {
  create?: Enumerable<AnswersheetCreateWithoutStudentInput>
  connect?: Enumerable<AnswersheetWhereUniqueInput>
}

export type StudentCreateWithoutCourseInput = {
  person: PersonCreateOneWithoutStudentsInput
  answersheets?: AnswersheetCreateManyWithoutStudentInput | null
}

export type StudentCreateManyWithoutCourseInput = {
  create?: Enumerable<StudentCreateWithoutCourseInput>
  connect?: Enumerable<StudentWhereUniqueInput>
}

export type CourseCreateWithoutOwnerInput = {
  description?: string | null
  name: string
  startdate: string
  exams?: ExamCreateManyWithoutCourseInput | null
  students?: StudentCreateManyWithoutCourseInput | null
}

export type CourseCreateOneWithoutOwnerInput = {
  create?: CourseCreateWithoutOwnerInput
  connect?: CourseWhereUniqueInput
}

export type OwnerCreateWithoutPersonInput = {
  course: CourseCreateOneWithoutOwnerInput
}

export type OwnerCreateManyWithoutPersonInput = {
  create?: Enumerable<OwnerCreateWithoutPersonInput>
  connect?: Enumerable<OwnerWhereUniqueInput>
}

export type PersonCreateWithoutStudentsInput = {
  email: string
  password: string
  name: string
  owners?: OwnerCreateManyWithoutPersonInput | null
}

export type PersonCreateOneWithoutStudentsInput = {
  create?: PersonCreateWithoutStudentsInput
  connect?: PersonWhereUniqueInput
}

export type StudentCreateWithoutAnswersheetsInput = {
  course: CourseCreateOneWithoutStudentsInput
  person: PersonCreateOneWithoutStudentsInput
}

export type StudentCreateOneWithoutAnswersheetsInput = {
  create?: StudentCreateWithoutAnswersheetsInput
  connect?: StudentWhereUniqueInput
}

export type AnswersheetCreateWithoutExamInput = {
  score?: number | null
  date: string
  answers?: AnswersheetCreateanswersInput
  student: StudentCreateOneWithoutAnswersheetsInput
}

export type AnswersheetCreateManyWithoutExamInput = {
  create?: Enumerable<AnswersheetCreateWithoutExamInput>
  connect?: Enumerable<AnswersheetWhereUniqueInput>
}

export type QuestionCreatechoicesInput = {
  set?: Enumerable<string> | null
}

export type QuestionCreateWithoutExamInput = {
  answer: number
  text: string
  choices?: QuestionCreatechoicesInput
}

export type QuestionCreateManyWithoutExamInput = {
  create?: Enumerable<QuestionCreateWithoutExamInput>
  connect?: Enumerable<QuestionWhereUniqueInput>
}

export type ExamCreateWithoutCourseInput = {
  title: string
  isCalculated?: boolean
  date: string
  duration: number
  answersheets?: AnswersheetCreateManyWithoutExamInput | null
  questions?: QuestionCreateManyWithoutExamInput | null
}

export type ExamCreateManyWithoutCourseInput = {
  create?: Enumerable<ExamCreateWithoutCourseInput>
  connect?: Enumerable<ExamWhereUniqueInput>
}

export type CourseCreateWithoutStudentsInput = {
  description?: string | null
  name: string
  startdate: string
  exams?: ExamCreateManyWithoutCourseInput | null
  owner?: OwnerCreateOneWithoutCourseInput | null
}

export type CourseCreateOneWithoutStudentsInput = {
  create?: CourseCreateWithoutStudentsInput
  connect?: CourseWhereUniqueInput
}

export type StudentCreateWithoutPersonInput = {
  course: CourseCreateOneWithoutStudentsInput
  answersheets?: AnswersheetCreateManyWithoutStudentInput | null
}

export type StudentCreateManyWithoutPersonInput = {
  create?: Enumerable<StudentCreateWithoutPersonInput>
  connect?: Enumerable<StudentWhereUniqueInput>
}

export type PersonCreateWithoutOwnersInput = {
  email: string
  password: string
  name: string
  students?: StudentCreateManyWithoutPersonInput | null
}

export type PersonCreateOneWithoutOwnersInput = {
  create?: PersonCreateWithoutOwnersInput
  connect?: PersonWhereUniqueInput
}

export type OwnerCreateWithoutCourseInput = {
  person: PersonCreateOneWithoutOwnersInput
}

export type OwnerCreateOneWithoutCourseInput = {
  create?: OwnerCreateWithoutCourseInput
  connect?: OwnerWhereUniqueInput
}

export type CourseCreateWithoutExamsInput = {
  description?: string | null
  name: string
  startdate: string
  owner?: OwnerCreateOneWithoutCourseInput | null
  students?: StudentCreateManyWithoutCourseInput | null
}

export type CourseCreateOneWithoutExamsInput = {
  create?: CourseCreateWithoutExamsInput
  connect?: CourseWhereUniqueInput
}

export type ExamCreateWithoutAnswersheetsInput = {
  title: string
  isCalculated?: boolean
  date: string
  duration: number
  course: CourseCreateOneWithoutExamsInput
  questions?: QuestionCreateManyWithoutExamInput | null
}

export type ExamCreateOneWithoutAnswersheetsInput = {
  create?: ExamCreateWithoutAnswersheetsInput
  connect?: ExamWhereUniqueInput
}

export type AnswersheetCreateInput = {
  score?: number | null
  date: string
  answers?: AnswersheetCreateanswersInput
  exam: ExamCreateOneWithoutAnswersheetsInput
  student: StudentCreateOneWithoutAnswersheetsInput
}

export type AnswersheetUpdateanswersInput = {
  set?: Enumerable<number> | null
}

export type AnswersheetUpdateWithoutStudentDataInput = {
  score?: number | null
  date?: string
  answers?: AnswersheetUpdateanswersInput
  exam?: ExamUpdateOneRequiredWithoutAnswersheetsInput | null
}

export type AnswersheetUpdateWithWhereUniqueWithoutStudentInput = {
  where: AnswersheetWhereUniqueInput
  data: AnswersheetUpdateWithoutStudentDataInput
}

export type AnswersheetScalarWhereInput = {
  score?: number | NullableIntFilter | null
  date?: string | StringFilter
  exam_id?: number | IntFilter
  id?: number | IntFilter
  student_id?: number | IntFilter
  AND?: Enumerable<AnswersheetScalarWhereInput>
  OR?: Array<AnswersheetScalarWhereInput>
  NOT?: Enumerable<AnswersheetScalarWhereInput>
}

export type AnswersheetUpdateManyDataInput = {
  score?: number | null
  date?: string
  answers?: AnswersheetUpdateanswersInput
}

export type AnswersheetUpdateManyWithWhereNestedInput = {
  where: AnswersheetScalarWhereInput
  data: AnswersheetUpdateManyDataInput
}

export type AnswersheetUpsertWithWhereUniqueWithoutStudentInput = {
  where: AnswersheetWhereUniqueInput
  update: AnswersheetUpdateWithoutStudentDataInput
  create: AnswersheetCreateWithoutStudentInput
}

export type AnswersheetUpdateManyWithoutStudentInput = {
  create?: Enumerable<AnswersheetCreateWithoutStudentInput>
  connect?: Enumerable<AnswersheetWhereUniqueInput>
  set?: Enumerable<AnswersheetWhereUniqueInput>
  disconnect?: Enumerable<AnswersheetWhereUniqueInput>
  delete?: Enumerable<AnswersheetWhereUniqueInput>
  update?: Enumerable<AnswersheetUpdateWithWhereUniqueWithoutStudentInput>
  updateMany?: Enumerable<AnswersheetUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<AnswersheetScalarWhereInput>
  upsert?: Enumerable<AnswersheetUpsertWithWhereUniqueWithoutStudentInput>
}

export type StudentUpdateWithoutCourseDataInput = {
  person?: PersonUpdateOneRequiredWithoutStudentsInput | null
  answersheets?: AnswersheetUpdateManyWithoutStudentInput | null
}

export type StudentUpdateWithWhereUniqueWithoutCourseInput = {
  where: StudentWhereUniqueInput
  data: StudentUpdateWithoutCourseDataInput
}

export type StudentScalarWhereInput = {
  course_id?: number | IntFilter
  id?: number | IntFilter
  person_id?: number | IntFilter
  answersheets?: AnswersheetFilter | null
  AND?: Enumerable<StudentScalarWhereInput>
  OR?: Array<StudentScalarWhereInput>
  NOT?: Enumerable<StudentScalarWhereInput>
}

export type StudentUpdateManyDataInput = {

}

export type StudentUpdateManyWithWhereNestedInput = {
  where: StudentScalarWhereInput
  data: StudentUpdateManyDataInput
}

export type StudentUpsertWithWhereUniqueWithoutCourseInput = {
  where: StudentWhereUniqueInput
  update: StudentUpdateWithoutCourseDataInput
  create: StudentCreateWithoutCourseInput
}

export type StudentUpdateManyWithoutCourseInput = {
  create?: Enumerable<StudentCreateWithoutCourseInput>
  connect?: Enumerable<StudentWhereUniqueInput>
  set?: Enumerable<StudentWhereUniqueInput>
  disconnect?: Enumerable<StudentWhereUniqueInput>
  delete?: Enumerable<StudentWhereUniqueInput>
  update?: Enumerable<StudentUpdateWithWhereUniqueWithoutCourseInput>
  updateMany?: Enumerable<StudentUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<StudentScalarWhereInput>
  upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutCourseInput>
}

export type CourseUpdateWithoutOwnerDataInput = {
  description?: string | null
  name?: string
  startdate?: string
  exams?: ExamUpdateManyWithoutCourseInput | null
  students?: StudentUpdateManyWithoutCourseInput | null
}

export type CourseUpsertWithoutOwnerInput = {
  update: CourseUpdateWithoutOwnerDataInput
  create: CourseCreateWithoutOwnerInput
}

export type CourseUpdateOneRequiredWithoutOwnerInput = {
  create?: CourseCreateWithoutOwnerInput
  connect?: CourseWhereUniqueInput
  update?: CourseUpdateWithoutOwnerDataInput
  upsert?: CourseUpsertWithoutOwnerInput
}

export type OwnerUpdateWithoutPersonDataInput = {
  course?: CourseUpdateOneRequiredWithoutOwnerInput | null
}

export type OwnerUpdateWithWhereUniqueWithoutPersonInput = {
  where: OwnerWhereUniqueInput
  data: OwnerUpdateWithoutPersonDataInput
}

export type OwnerScalarWhereInput = {
  course_id?: number | IntFilter
  id?: number | IntFilter
  person_id?: number | IntFilter
  AND?: Enumerable<OwnerScalarWhereInput>
  OR?: Array<OwnerScalarWhereInput>
  NOT?: Enumerable<OwnerScalarWhereInput>
}

export type OwnerUpdateManyDataInput = {

}

export type OwnerUpdateManyWithWhereNestedInput = {
  where: OwnerScalarWhereInput
  data: OwnerUpdateManyDataInput
}

export type OwnerUpsertWithWhereUniqueWithoutPersonInput = {
  where: OwnerWhereUniqueInput
  update: OwnerUpdateWithoutPersonDataInput
  create: OwnerCreateWithoutPersonInput
}

export type OwnerUpdateManyWithoutPersonInput = {
  create?: Enumerable<OwnerCreateWithoutPersonInput>
  connect?: Enumerable<OwnerWhereUniqueInput>
  set?: Enumerable<OwnerWhereUniqueInput>
  disconnect?: Enumerable<OwnerWhereUniqueInput>
  delete?: Enumerable<OwnerWhereUniqueInput>
  update?: Enumerable<OwnerUpdateWithWhereUniqueWithoutPersonInput>
  updateMany?: Enumerable<OwnerUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<OwnerScalarWhereInput>
  upsert?: Enumerable<OwnerUpsertWithWhereUniqueWithoutPersonInput>
}

export type PersonUpdateWithoutStudentsDataInput = {
  email?: string
  password?: string
  name?: string
  owners?: OwnerUpdateManyWithoutPersonInput | null
}

export type PersonUpsertWithoutStudentsInput = {
  update: PersonUpdateWithoutStudentsDataInput
  create: PersonCreateWithoutStudentsInput
}

export type PersonUpdateOneRequiredWithoutStudentsInput = {
  create?: PersonCreateWithoutStudentsInput
  connect?: PersonWhereUniqueInput
  update?: PersonUpdateWithoutStudentsDataInput
  upsert?: PersonUpsertWithoutStudentsInput
}

export type StudentUpdateWithoutAnswersheetsDataInput = {
  course?: CourseUpdateOneRequiredWithoutStudentsInput | null
  person?: PersonUpdateOneRequiredWithoutStudentsInput | null
}

export type StudentUpsertWithoutAnswersheetsInput = {
  update: StudentUpdateWithoutAnswersheetsDataInput
  create: StudentCreateWithoutAnswersheetsInput
}

export type StudentUpdateOneRequiredWithoutAnswersheetsInput = {
  create?: StudentCreateWithoutAnswersheetsInput
  connect?: StudentWhereUniqueInput
  update?: StudentUpdateWithoutAnswersheetsDataInput
  upsert?: StudentUpsertWithoutAnswersheetsInput
}

export type AnswersheetUpdateWithoutExamDataInput = {
  score?: number | null
  date?: string
  answers?: AnswersheetUpdateanswersInput
  student?: StudentUpdateOneRequiredWithoutAnswersheetsInput | null
}

export type AnswersheetUpdateWithWhereUniqueWithoutExamInput = {
  where: AnswersheetWhereUniqueInput
  data: AnswersheetUpdateWithoutExamDataInput
}

export type AnswersheetUpsertWithWhereUniqueWithoutExamInput = {
  where: AnswersheetWhereUniqueInput
  update: AnswersheetUpdateWithoutExamDataInput
  create: AnswersheetCreateWithoutExamInput
}

export type AnswersheetUpdateManyWithoutExamInput = {
  create?: Enumerable<AnswersheetCreateWithoutExamInput>
  connect?: Enumerable<AnswersheetWhereUniqueInput>
  set?: Enumerable<AnswersheetWhereUniqueInput>
  disconnect?: Enumerable<AnswersheetWhereUniqueInput>
  delete?: Enumerable<AnswersheetWhereUniqueInput>
  update?: Enumerable<AnswersheetUpdateWithWhereUniqueWithoutExamInput>
  updateMany?: Enumerable<AnswersheetUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<AnswersheetScalarWhereInput>
  upsert?: Enumerable<AnswersheetUpsertWithWhereUniqueWithoutExamInput>
}

export type QuestionUpdatechoicesInput = {
  set?: Enumerable<string> | null
}

export type QuestionUpdateWithoutExamDataInput = {
  answer?: number
  text?: string
  choices?: QuestionUpdatechoicesInput
}

export type QuestionUpdateWithWhereUniqueWithoutExamInput = {
  where: QuestionWhereUniqueInput
  data: QuestionUpdateWithoutExamDataInput
}

export type QuestionScalarWhereInput = {
  answer?: number | IntFilter
  exam_id?: number | IntFilter
  id?: number | IntFilter
  text?: string | StringFilter
  AND?: Enumerable<QuestionScalarWhereInput>
  OR?: Array<QuestionScalarWhereInput>
  NOT?: Enumerable<QuestionScalarWhereInput>
}

export type QuestionUpdateManyDataInput = {
  answer?: number
  text?: string
  choices?: QuestionUpdatechoicesInput
}

export type QuestionUpdateManyWithWhereNestedInput = {
  where: QuestionScalarWhereInput
  data: QuestionUpdateManyDataInput
}

export type QuestionUpsertWithWhereUniqueWithoutExamInput = {
  where: QuestionWhereUniqueInput
  update: QuestionUpdateWithoutExamDataInput
  create: QuestionCreateWithoutExamInput
}

export type QuestionUpdateManyWithoutExamInput = {
  create?: Enumerable<QuestionCreateWithoutExamInput>
  connect?: Enumerable<QuestionWhereUniqueInput>
  set?: Enumerable<QuestionWhereUniqueInput>
  disconnect?: Enumerable<QuestionWhereUniqueInput>
  delete?: Enumerable<QuestionWhereUniqueInput>
  update?: Enumerable<QuestionUpdateWithWhereUniqueWithoutExamInput>
  updateMany?: Enumerable<QuestionUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<QuestionScalarWhereInput>
  upsert?: Enumerable<QuestionUpsertWithWhereUniqueWithoutExamInput>
}

export type ExamUpdateWithoutCourseDataInput = {
  title?: string
  isCalculated?: boolean
  date?: string
  duration?: number
  answersheets?: AnswersheetUpdateManyWithoutExamInput | null
  questions?: QuestionUpdateManyWithoutExamInput | null
}

export type ExamUpdateWithWhereUniqueWithoutCourseInput = {
  where: ExamWhereUniqueInput
  data: ExamUpdateWithoutCourseDataInput
}

export type ExamScalarWhereInput = {
  course_id?: number | IntFilter
  title?: string | StringFilter
  isCalculated?: boolean | BooleanFilter
  date?: string | StringFilter
  duration?: number | IntFilter
  id?: number | IntFilter
  answersheets?: AnswersheetFilter | null
  questions?: QuestionFilter | null
  AND?: Enumerable<ExamScalarWhereInput>
  OR?: Array<ExamScalarWhereInput>
  NOT?: Enumerable<ExamScalarWhereInput>
}

export type ExamUpdateManyDataInput = {
  title?: string
  isCalculated?: boolean
  date?: string
  duration?: number
}

export type ExamUpdateManyWithWhereNestedInput = {
  where: ExamScalarWhereInput
  data: ExamUpdateManyDataInput
}

export type ExamUpsertWithWhereUniqueWithoutCourseInput = {
  where: ExamWhereUniqueInput
  update: ExamUpdateWithoutCourseDataInput
  create: ExamCreateWithoutCourseInput
}

export type ExamUpdateManyWithoutCourseInput = {
  create?: Enumerable<ExamCreateWithoutCourseInput>
  connect?: Enumerable<ExamWhereUniqueInput>
  set?: Enumerable<ExamWhereUniqueInput>
  disconnect?: Enumerable<ExamWhereUniqueInput>
  delete?: Enumerable<ExamWhereUniqueInput>
  update?: Enumerable<ExamUpdateWithWhereUniqueWithoutCourseInput>
  updateMany?: Enumerable<ExamUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<ExamScalarWhereInput>
  upsert?: Enumerable<ExamUpsertWithWhereUniqueWithoutCourseInput>
}

export type CourseUpdateWithoutStudentsDataInput = {
  description?: string | null
  name?: string
  startdate?: string
  exams?: ExamUpdateManyWithoutCourseInput | null
  owner?: OwnerUpdateOneRequiredWithoutCourseInput | null
}

export type CourseUpsertWithoutStudentsInput = {
  update: CourseUpdateWithoutStudentsDataInput
  create: CourseCreateWithoutStudentsInput
}

export type CourseUpdateOneRequiredWithoutStudentsInput = {
  create?: CourseCreateWithoutStudentsInput
  connect?: CourseWhereUniqueInput
  update?: CourseUpdateWithoutStudentsDataInput
  upsert?: CourseUpsertWithoutStudentsInput
}

export type StudentUpdateWithoutPersonDataInput = {
  course?: CourseUpdateOneRequiredWithoutStudentsInput | null
  answersheets?: AnswersheetUpdateManyWithoutStudentInput | null
}

export type StudentUpdateWithWhereUniqueWithoutPersonInput = {
  where: StudentWhereUniqueInput
  data: StudentUpdateWithoutPersonDataInput
}

export type StudentUpsertWithWhereUniqueWithoutPersonInput = {
  where: StudentWhereUniqueInput
  update: StudentUpdateWithoutPersonDataInput
  create: StudentCreateWithoutPersonInput
}

export type StudentUpdateManyWithoutPersonInput = {
  create?: Enumerable<StudentCreateWithoutPersonInput>
  connect?: Enumerable<StudentWhereUniqueInput>
  set?: Enumerable<StudentWhereUniqueInput>
  disconnect?: Enumerable<StudentWhereUniqueInput>
  delete?: Enumerable<StudentWhereUniqueInput>
  update?: Enumerable<StudentUpdateWithWhereUniqueWithoutPersonInput>
  updateMany?: Enumerable<StudentUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<StudentScalarWhereInput>
  upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutPersonInput>
}

export type PersonUpdateWithoutOwnersDataInput = {
  email?: string
  password?: string
  name?: string
  students?: StudentUpdateManyWithoutPersonInput | null
}

export type PersonUpsertWithoutOwnersInput = {
  update: PersonUpdateWithoutOwnersDataInput
  create: PersonCreateWithoutOwnersInput
}

export type PersonUpdateOneRequiredWithoutOwnersInput = {
  create?: PersonCreateWithoutOwnersInput
  connect?: PersonWhereUniqueInput
  update?: PersonUpdateWithoutOwnersDataInput
  upsert?: PersonUpsertWithoutOwnersInput
}

export type OwnerUpdateWithoutCourseDataInput = {
  person?: PersonUpdateOneRequiredWithoutOwnersInput | null
}

export type OwnerUpsertWithoutCourseInput = {
  update: OwnerUpdateWithoutCourseDataInput
  create: OwnerCreateWithoutCourseInput
}

export type OwnerUpdateOneRequiredWithoutCourseInput = {
  create?: OwnerCreateWithoutCourseInput
  connect?: OwnerWhereUniqueInput
  update?: OwnerUpdateWithoutCourseDataInput
  upsert?: OwnerUpsertWithoutCourseInput
}

export type CourseUpdateWithoutExamsDataInput = {
  description?: string | null
  name?: string
  startdate?: string
  owner?: OwnerUpdateOneRequiredWithoutCourseInput | null
  students?: StudentUpdateManyWithoutCourseInput | null
}

export type CourseUpsertWithoutExamsInput = {
  update: CourseUpdateWithoutExamsDataInput
  create: CourseCreateWithoutExamsInput
}

export type CourseUpdateOneRequiredWithoutExamsInput = {
  create?: CourseCreateWithoutExamsInput
  connect?: CourseWhereUniqueInput
  update?: CourseUpdateWithoutExamsDataInput
  upsert?: CourseUpsertWithoutExamsInput
}

export type ExamUpdateWithoutAnswersheetsDataInput = {
  title?: string
  isCalculated?: boolean
  date?: string
  duration?: number
  course?: CourseUpdateOneRequiredWithoutExamsInput | null
  questions?: QuestionUpdateManyWithoutExamInput | null
}

export type ExamUpsertWithoutAnswersheetsInput = {
  update: ExamUpdateWithoutAnswersheetsDataInput
  create: ExamCreateWithoutAnswersheetsInput
}

export type ExamUpdateOneRequiredWithoutAnswersheetsInput = {
  create?: ExamCreateWithoutAnswersheetsInput
  connect?: ExamWhereUniqueInput
  update?: ExamUpdateWithoutAnswersheetsDataInput
  upsert?: ExamUpsertWithoutAnswersheetsInput
}

export type AnswersheetUpdateInput = {
  score?: number | null
  date?: string
  answers?: AnswersheetUpdateanswersInput
  exam?: ExamUpdateOneRequiredWithoutAnswersheetsInput | null
  student?: StudentUpdateOneRequiredWithoutAnswersheetsInput | null
}

export type AnswersheetUpdateManyMutationInput = {
  score?: number | null
  date?: string
  answers?: AnswersheetUpdateanswersInput
}

export type CourseCreateInput = {
  description?: string | null
  name: string
  startdate: string
  exams?: ExamCreateManyWithoutCourseInput | null
  owner?: OwnerCreateOneWithoutCourseInput | null
  students?: StudentCreateManyWithoutCourseInput | null
}

export type CourseUpdateInput = {
  description?: string | null
  name?: string
  startdate?: string
  exams?: ExamUpdateManyWithoutCourseInput | null
  owner?: OwnerUpdateOneRequiredWithoutCourseInput | null
  students?: StudentUpdateManyWithoutCourseInput | null
}

export type CourseUpdateManyMutationInput = {
  description?: string | null
  name?: string
  startdate?: string
}

export type ExamCreateInput = {
  title: string
  isCalculated?: boolean
  date: string
  duration: number
  course: CourseCreateOneWithoutExamsInput
  answersheets?: AnswersheetCreateManyWithoutExamInput | null
  questions?: QuestionCreateManyWithoutExamInput | null
}

export type ExamUpdateInput = {
  title?: string
  isCalculated?: boolean
  date?: string
  duration?: number
  course?: CourseUpdateOneRequiredWithoutExamsInput | null
  answersheets?: AnswersheetUpdateManyWithoutExamInput | null
  questions?: QuestionUpdateManyWithoutExamInput | null
}

export type ExamUpdateManyMutationInput = {
  title?: string
  isCalculated?: boolean
  date?: string
  duration?: number
}

export type OwnerCreateInput = {
  course: CourseCreateOneWithoutOwnerInput
  person: PersonCreateOneWithoutOwnersInput
}

export type OwnerUpdateInput = {
  course?: CourseUpdateOneRequiredWithoutOwnerInput | null
  person?: PersonUpdateOneRequiredWithoutOwnersInput | null
}

export type OwnerUpdateManyMutationInput = {

}

export type PersonCreateInput = {
  email: string
  password: string
  name: string
  owners?: OwnerCreateManyWithoutPersonInput | null
  students?: StudentCreateManyWithoutPersonInput | null
}

export type PersonUpdateInput = {
  email?: string
  password?: string
  name?: string
  owners?: OwnerUpdateManyWithoutPersonInput | null
  students?: StudentUpdateManyWithoutPersonInput | null
}

export type PersonUpdateManyMutationInput = {
  email?: string
  password?: string
  name?: string
}

export type ExamCreateWithoutQuestionsInput = {
  title: string
  isCalculated?: boolean
  date: string
  duration: number
  course: CourseCreateOneWithoutExamsInput
  answersheets?: AnswersheetCreateManyWithoutExamInput | null
}

export type ExamCreateOneWithoutQuestionsInput = {
  create?: ExamCreateWithoutQuestionsInput
  connect?: ExamWhereUniqueInput
}

export type QuestionCreateInput = {
  answer: number
  text: string
  choices?: QuestionCreatechoicesInput
  exam: ExamCreateOneWithoutQuestionsInput
}

export type ExamUpdateWithoutQuestionsDataInput = {
  title?: string
  isCalculated?: boolean
  date?: string
  duration?: number
  course?: CourseUpdateOneRequiredWithoutExamsInput | null
  answersheets?: AnswersheetUpdateManyWithoutExamInput | null
}

export type ExamUpsertWithoutQuestionsInput = {
  update: ExamUpdateWithoutQuestionsDataInput
  create: ExamCreateWithoutQuestionsInput
}

export type ExamUpdateOneRequiredWithoutQuestionsInput = {
  create?: ExamCreateWithoutQuestionsInput
  connect?: ExamWhereUniqueInput
  update?: ExamUpdateWithoutQuestionsDataInput
  upsert?: ExamUpsertWithoutQuestionsInput
}

export type QuestionUpdateInput = {
  answer?: number
  text?: string
  choices?: QuestionUpdatechoicesInput
  exam?: ExamUpdateOneRequiredWithoutQuestionsInput | null
}

export type QuestionUpdateManyMutationInput = {
  answer?: number
  text?: string
  choices?: QuestionUpdatechoicesInput
}

export type StudentCreateInput = {
  course: CourseCreateOneWithoutStudentsInput
  person: PersonCreateOneWithoutStudentsInput
  answersheets?: AnswersheetCreateManyWithoutStudentInput | null
}

export type StudentUpdateInput = {
  course?: CourseUpdateOneRequiredWithoutStudentsInput | null
  person?: PersonUpdateOneRequiredWithoutStudentsInput | null
  answersheets?: AnswersheetUpdateManyWithoutStudentInput | null
}

export type StudentUpdateManyMutationInput = {

}

export type AdminCreateInput = {
  email: string
  password: string
}

export type AdminUpdateInput = {
  email?: string
  password?: string
}

export type AdminUpdateManyMutationInput = {
  email?: string
  password?: string
}

export type IntFilter = {
  equals?: number
  not?: number | IntFilter
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
}

export type AnswersheetFilter = {
  every?: AnswersheetWhereInput
  some?: AnswersheetWhereInput
  none?: AnswersheetWhereInput
}

export type StringFilter = {
  equals?: string
  not?: string | StringFilter
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
}

export type OwnerFilter = {
  every?: OwnerWhereInput
  some?: OwnerWhereInput
  none?: OwnerWhereInput
}

export type StudentFilter = {
  every?: StudentWhereInput
  some?: StudentWhereInput
  none?: StudentWhereInput
}

export type NullableStringFilter = {
  equals?: string | null
  not?: string | null | NullableStringFilter
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
}

export type ExamFilter = {
  every?: ExamWhereInput
  some?: ExamWhereInput
  none?: ExamWhereInput
}

export type BooleanFilter = {
  equals?: boolean
  not?: boolean | BooleanFilter
}

export type QuestionFilter = {
  every?: QuestionWhereInput
  some?: QuestionWhereInput
  none?: QuestionWhereInput
}

export type NullableIntFilter = {
  equals?: number | null
  not?: number | null | NullableIntFilter
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
}

export type AnswersheetOrderByInput = {
  score?: OrderByArg | null
  date?: OrderByArg | null
  exam_id?: OrderByArg | null
  id?: OrderByArg | null
  student_id?: OrderByArg | null
}

export type ExamOrderByInput = {
  course_id?: OrderByArg | null
  title?: OrderByArg | null
  isCalculated?: OrderByArg | null
  date?: OrderByArg | null
  duration?: OrderByArg | null
  id?: OrderByArg | null
}

export type OwnerOrderByInput = {
  course_id?: OrderByArg | null
  id?: OrderByArg | null
  person_id?: OrderByArg | null
}

export type StudentOrderByInput = {
  course_id?: OrderByArg | null
  id?: OrderByArg | null
  person_id?: OrderByArg | null
}

export type QuestionOrderByInput = {
  answer?: OrderByArg | null
  exam_id?: OrderByArg | null
  id?: OrderByArg | null
  text?: OrderByArg | null
}

export type CourseOrderByInput = {
  id?: OrderByArg | null
  description?: OrderByArg | null
  name?: OrderByArg | null
  startdate?: OrderByArg | null
}

export type PersonOrderByInput = {
  email?: OrderByArg | null
  password?: OrderByArg | null
  name?: OrderByArg | null
  id?: OrderByArg | null
}

export type AdminOrderByInput = {
  id?: OrderByArg | null
  email?: OrderByArg | null
  password?: OrderByArg | null
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
